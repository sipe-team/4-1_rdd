# 쿼리 튜닝 회고

### 배경

기존 배치 쿼리에서 데이터가 많아지면서 길면 1시간 정도 걸리는 쿼리가 실행되었다. 배치 시스템에서 기본 쿼리 타임아웃 값이 1시간이어서 종종 쿼리 타임아웃이 발생하였기 때문에 빠르게 해결해야 하는 상황이었다.

### 인덱스 힌트가 최선이었을까?

우선 데이터가 많아지고 통계정보가 최신 상태를 유지하지 못했기 때문에 옵티마이저가 원래의 인덱스를 찾아가지 못하는 경우라고 판단하였다. 이를 해결하기 위해서 DBA한테 DB 통계정보를 최신 상태로 유지해달라고 하였다.

이렇게 통계정보를 최신상태로 유지했으나 옵티마이저가 인덱스를 찾아가지 못하는 경우가 여전히 발생하였다. 왜 그럴까 분석해보니 복합 인덱스에서 컬럼 a(숫자), 컬럼 b(날짜)를 같이 사용중인데, 컬럼b 만 조건문에 존재해서 인덱스를 타지 않는 것이었다. 

이 쿼리를 분석했을 때는 인덱스에 대해서 그렇게 정확히 파악하고 있지 않은 상태였기 때문에 복합 인덱스에서 컬럼 하나만 존재해도 옵티마이저가 해당 인덱스를 찾아갈 것이라고 판단하였지만 아니었다. 따라서 컬럼 b가 앞에오는 인덱스를 추가하려고 하였으나 이미 해당 테이블에는 인덱스가 많아서 새로운 인덱스를 추가할 경우 다른 쿼리의 실행계획이 크게 뒤틀릴 수 있기 때문에 인덱스를 추가하는 것은 배제하였다.

따라서 UNION ALL로 두 개의 쿼리를 묶기로 결정하였다. 앞서 말한 복합 인덱스의 컬럼 a 는 상담순번으로 현재 운영 데이터 기준으로 0, 1, 2, 3 이 최대였기 때문에 UNION ALL의 앞선 쿼리는 IN 절로 0, 1, 2, 3을 묶었고 뒤의 쿼리는 NOT IN 절로 0, 1, 2, 3 을 묶었다.

하지만 컬럼 a의 모든 레코드 값이 0, 1, 2, 3 안에 들어왔기 때문에 UNION ALL 뒤의 쿼리는 옵티마이저가 복합 인덱스를 찾아가지 않았다. 무수한 고민을 한 결과 뒤의 쿼리에 인덱스 힌트를 두어 강제로 복합인덱스를 타게 하여 range index scan 을 하도록 하였다. 컬럼 b가 날짜 조건이었기 때문에 range index scan 을 하게 된 것이다. 이렇게 하여 1시간이 걸리던 쿼리를 1분 ~ 5분 내외로 실행시간을 단축시켰다.

하지만 인덱스 힌트는 DB의 통계정보가 바뀌어 옵티마이저가 더 좋은 실행계획을 찾아도 계속해서 해당 인덱스를 강제로 타게된다. 이는 추후에 데이터가 많이 쌓여서 옵티마이저가 더 좋은 실행계획을 찾으면 문제가 생길 수 있다. 그렇다면 이 방법은 괜찮은 방법이었을까?

해당 쿼리를 다시 분석해보면 날짜조건(컬럼 b)가 무조건 필요하다. 날짜조건에 대한 인덱스는 range index scan 을 하게된다. 그리고 날짜조건에 대한 범위가 그렇게 크지 않았기 때문에 인덱스 힌트를 두어 해당 복합 인덱스를 타게한 것도 괜찮은 선택이었던 것 같다. 앞선 컬럼 a는 IN 과 NOT IN 으로 모든 컬럼 a 값에 대해서 조건을 걸었기 때문에 문제는 없어보인다.