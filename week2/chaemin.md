# 실시간 에러 알림 시스템 회고

#### 반복 알림을 줄이기 위해서 캐시를 꼭 사용해야 했을까?

기존 시스템에서는 동일한 에러가 발생하면 장애가 해소될 때까지 알림이 지속적으로 발송되었다. 이를 해결하기 위해서 '개발자가 지속적인 장애인지 인지하기까지의 몇 번의 알림이 필요할까' 에 대해서 고민해본 결과 최대 5번 정도 알림을 발송하면 해당 에러가 일시적인 에러인지 반복적인 에러인지 인지할 수 있다고 판단하였다.

반복 에러를 최대 5번까지만 발송하게 하려면 5번을 특정 데이터 소스에 저장을 해야할 것이다. 하지만 데이터 소스에 해당 에러를 5번의 횟수까지 저장하고 또 다른날에 동일한 에러가 발생한다면 이미 5번을 초과했기 때문에 알림이 발송되지 않을 것이다. 해당 에러를 최초에 해소를 했더라도 추후에 다시 장애가 발생한다면 알림이 울리지 않아서 장애를 인지하지 못할 것이고, 이는 큰 장애로 이어질 수 있을 것이다.

그렇다면 반복 에러를 특정 순간에는 5번까지 제한하고 일정 시간이 지나면 동일한 알림이 다시 발송되도록 하려면 어떻게 해야할까? 나는 이를 해결하기 위해서 캐시를 선택하였다. 또한 k8s의 멀티 Pod 환경이었기 때문에 로컬 캐시가 아닌 글로벌 캐시를 선택하였다. 캐시를 선택한 이유는 캐시는 TTL(Time To Live)를 설정하여 특정 데이터의 생명주기를 설정하여 자동으로 소멸되게 할 수 있기 때문이다. 이 때문에 반복적으로 발생하는 알림은 캐시에 해당 에러 존재여부로 판단하고, 추후에 해당 에러가 캐시에서 소멸되면 다시 알림을 받을 수 있게 되는 것이다.

그럼 반복 알림을 줄이기 위해서 캐시를 꼭 사용해야 했을까? 캐시를 사용하지 않더라도 TTL의 기능이 있는 데이터 소스이거나 또는 소멸주기를 구현해야만 했을 것이다. 예를들면 AWS DynamoDB 의 기능인 TTL 기능을 사용하면 동일한 느낌으로 구현할 수 있을 것이다. 또한 RDBMS에 저장하고 이벤트 스케줄러를 활용하여 레코드에 소멸주기를 지정할 수도 있을 것이다.

그렇다면 Redis를 사용하는 방식이 가장 적합했을까? 목적, 소멸주기, 지연시간에 대해서 비교해보자.

**목적**

목적은 '반복 알림'이 최근에 존재했는 지 파악하는 것이다. 데이터 특성상 해당 데이터는 영구적인 저장이 필요없는 데이터라는 것이다. DynamoDB와 RDBMS는 보통 영구적인 목적의 데이터를 저장하기 위해서 사용한다. 하지만 Redis와 같은 캐시 메모리는 시간이 지나서 휘발되어도 상관없는 데이터를 저장한다. 따라서 목적을 생각해보면 Redis가 가장 적합했던 것 같다.

**소멸주기**

소멸주기는 Redis, DynamoDB, RDBMS 모두 다 나름대로 지정할 수 있다. DynamoDB은 TTL을 설정하여 만료일시를 설정할 수 있다. RDBMS를 사용하면 이벤트 스케줄링과 같은 작업을 별도로 실행하여 일정 주기에 따라서 특정 쿼리를 수행하도록 해야한다. 이는 DB에 부하를 줄 수 있고 Redis 처럼 인메모리 기반이 아닌 디스크에 직접 쓰고 조회하는 방식의 데이터 소스이기 때문에 문제가 발생할 수 있다. 소멸주기의 적합성을 따지면 Redis와 DynamoDB 모두 적합했던 것 같다.

**지연시간**

트래픽이 몰리거나 많이 발생하는 API는 장애가 발생하면 1초에 수백, 수천건씩 나올 수 있다. RDBMS에 에러를 저장하여 동일한 에러인지 아닌지 판별한다면 디스크에 직접 쓰고 조회하기 때문에 부하가 많이 걸릴 수 있고, 이에 따라서 지연시간이 높아질 수 있다. DynamoDB의 경우에는 RDBMS 보다는 우수한 성능을 보여주지만 네트워크 호출 및 내부 로직으로 인하여 Redis 보다는 지연시간이 길다. Redis는 인메모리(RAM) 기반으로 데이터를 읽고 쓰기 때문에 응답속도가 굉장히 빠르므로 가장 적합하다.

**결론**

Redis와 DynamoDB 모두 반복된 에러인지 판단하기 위한 데이터를 저장하는 데이터 소스에 적합해 보인다. 하지만 다음과 같은 이유로 Redis가 더 적합하다고 판단하였다.

- 비영구 목적의 데이터
- 낮은 지연시간

#### 완벽하게 동일한 알림인지 구분할 수 있는 방법은 없을까?

현재 동일한 에러인지 구분하는 척도로 다음과 같은 속성이 모두 일치한지에 대해서 판단하고 있다.

- 예외구분(Open API, Biz, Runtime 등)
- 모듈(MSA)
- 환경(스테이징, 운영)
- Request URL
- Request Http Method
- 예외 발생 경로
- 예외 상세 내용

언뜻 보면 위와 같은 속성들을 묶어 동일한 알림인지 구분할 수 있을 듯 하다. 하지만 최근에 동일한 에러인데도 불구하고 다른 알림으로 인식하고 발생한 에러가 있었다. 이는 예외 발생 경로 때문인데, 예외 발생 경로가 동일하지만 경로를 찾아서 삽입할 때 프록시 객체의 경로가 들어가서 다르게 판단했던 것이다. 동일한 경로에서 예외가 발생하더라도 프록시 객체가 특정 메서드를 호출하면 프록시 객체의 힙 주소가 다를 수 있다.

이에 따라서 경로를 구분하는 로직에서 프록시 객체의 주소를 제외하고 경로를 구분하는 로직으로 개선할 예정이다. 이렇게 된다면 완벽하게 동일한 알림인지 구분할 수 있을 것이다.

#### 캐시에 들어간 에러들을 WriteBack 패턴을 사용해서 주기적으로 RDB로 동기화시키고 있는데, RDB에 있는 데이터를 추후에 어떤 방식으로 활용하면 좋을까?

처음에는 캐시에 있는 데이터를 주기적으로 RDB로 동기화 시키는 이유가 Redis 장애 시 RDB에서 동일한 에러인지 판단하기 위해서였다. 이렇게 구현함으로써 데이터 소스와 시스템간의 결합도를 최소화했지만 RDB에 저장을 하면 영구적으로 데이터가 저장되어있기 때문에 Redis가 장애가 일어나지 않는다면 의미가 없는 데이터가 될 수 있다.

그렇다면 어떻게 RDB에 있는 데이터를 더 효율적으로 활용할 수 있을까? 에러알림시스템을 구축한 후 발생한 에러들 중 의미있는 데이터도 존재하지만 원인 모를 에러도 가끔 발생하고, 간헐적으로 발생하는 에러도 존재한다. 예를들면 평소에 Query Timeout이 발생하지 않은 데이터도 갑자기 발생해서 쿼리를 분석하고 로직을 분석해보면 Timeout이 실행될 수 없는 부분이 있다. 또한 파일을 S3에 업로드할 때 기다리지 못하고 페이지를 나가버리는 경우 Socket Exception이 발생하는 경우도 있다.

이러한 데이터들이 RDB에 쌓이면 이를 통계화 시켜서 분석하여 어떻게 해결하면 좋을 지 자동으로 분석하는 시스템을 구축하는 것도 좋아보인다. 

만약 좋은 아이디어가 있다면 의견 주시면 환영합니다. ^^