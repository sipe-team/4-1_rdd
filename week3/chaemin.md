# 인터페이스 이력 관리 시스템 회고

### 모든 종류의 이력을 남겨야 했을까?

인터페이스 이력 관리 시스템을 배포 후 무수히 많은 이력이 남는 것을 확인하고 불필요한 이력들을 남기지 않기 위해서 급하게 블랙리스트 기능을 도입하여 불필요한 이력을 남기지 않도록 처리하였다. 이렇게 함으로써 굳이 저장할 필요가 없는 이력들(단순 API 조회 등)을 남기지 않을 수 있어서 DB 스토리지에 과도한 데이터가 들어가지 않도록 하였다.

그렇다면 저장해야하는 이력과 저장할 필요가 없는 이력에 대한 척도는 무엇이었을까? 그때 당시에 내가 선택했던 척도는 다음과 같았다.

1. 호출 빈도
2. 데이터의 중요성

첫 번째 척도인 '호출 빈도'는 얼마나 해당 API 또는 인터페이스 요청이 많이 일어나는가? 이다. 호출 빈도가 1등이라고 무조건 이력을 남겨야 할지에 대한 고민을 굉장히 많이했었다. 그래서 내가 내린 결론은 호출 빈도가 상위권인 것들 중에서도 '데이터의 중요성'을 두 번째로 고민했었다.

두 번째 척도인 '데이터의 중요성'은 해당 데이터가 없어도 재현이 가능한가? 아니면 불가능한가? 이다. 단순 조회같은 API는 데이터가 굳이 없어도 코드를 분석해보면 무엇이 잘못되었는지 파악할 수 있다. 하지만 조회가 아닌 저장이나 업데이트를 해야하는 비즈니스 로직이 섞여있는 인터페이스 요청/응답은 정책이 무수히 많을 수 있고, 레거시 코드가 섞여있어서 데이터가 없다면 분석하기 쉽지 않을 확률이 높다.

따라서 이러한 두 개의 척도를 기준을 삼아서 '호출 빈도'는 많지만 '데이터의 중요성'이 크지 않은 인터페이스 이력은 저장하지 않도록 하였다.

#### 결론

지금 와서 생각해봐도 모든 종류의 이력을 남길 필요는 없는 것 같다. 남기려면 남길 수 있지만 불필요한 DB 스토리지를 차지하고, DB I/O 비용도 만만치 않게 드니 말이다.

또한 팀에 합류한지 그렇게 오래되지 않아서 무엇이 중요한 인터페이스 이력인지 아닌지 정확히 알 지 못해서 블랙리스트 전략을 선택한 이유도 있었다. 운영을 오래 해봤다면 무엇이 중요한 인터페이스 이력인지 구분할 수 있게 될 것이다. 그 때가 되면 블랙리스트보다 화이트리스트 전략이 더 효율적으로 이력을 관리하기 좋을지도 모르니 고민해봐야겠다.

### 언제까지의 이력을 저장하면 좋을까?

인터페이스 이력 관리 시스템을 구축한지 벌써 3개월이 넘었다. DB를 얼추 확인해보니 무수히 많은 데이터가 쌓여있는 것을 확인할 수 있었다. 인터페이스 이력을 볼 일은 생각보다 많지만 생각보다 많지 않다. 또한 시간이 지난 이력은 특수한 경우를 제외하고는 거의 볼 일이 없다.

요즈음 데이터가 너무 많이 쌓이고 있어서 오래 지난 이력에 대해서 슬슬 생명주기를 적용하려고 한다. 그렇다면 언제까지의 이력을 저장하면 좋을까? 인터페이스 이력 관리 시스템을 사용한 3개월 동안 운영을 하면서 3개월 이내에 데이터를 제일 많이 조회를 했었다. 그렇지만 3개월 이상 지난 데이터도 종종 조회하려고 했었다.(구축한지 3개월 밖에 안돼서 데이터가 없었음.. ㅠ)

지금까지 통계로 보았을 때 10번을 조회하면 6번을 1개월 이내의 데이터를 조회하고, 3번은 3개월 이내의 데이터를, 1번을 3개월 이후의 데이터를 조회하는 것 같다. 10번중에 3개월이 지난 데이터를 조회하는 일은 1번인데, 이 1번의 조회를 위해서 3개월 이상의 데이터를 저장해야 할까? 애매하게 4개월 또는 5개월의 생명주기를 지정하는 것도 뭔가 좀 그렇고, 그렇다고 6개월의 생명주기는 너무 길다.

#### 결론

이성적으로는 3개월 이상의 데이터는 과감하게 버리고, 3개월까지의 이력을 저장하는게 좋아 보이지만 심장은 모두를 저장하고 싶다.. 하지만 결정을 해야하기에 한 달 동안 운영 데이터를 분석해보고 3개월 또는 4개월도 정해보도록 해야겠다.

### Feat. 실시간 에러 알림 시스템 개선

저번주에 진행했던 실시간 에러 알림 시스템을 개선하기 시작했다. 저번주에 말했듯이 반복적으로 일어나는 에러의 횟수를 제한하기 위해서 동일한 에러인지 아닌지에 대한 척도를 몇 개의 속성값으로 세워서 구분하였다. 하지만 AOP 기반의 Spring Annotation을 사용한 메서드에서 에러가 발생하면 CGLIB 또는 JDK 동적 프록시가 대신 메서드를 호출하기 때문에 CGLIB$123123 과 같은 경로가 나오게 되었고, 이 경로의 접미사는 매번 에러가 발생할 때마다 바뀌는 현상이 나타나서 동일한 에러임에도 불구하고 다른 에러로 인식하였다.

추후에 찾아보니 CGLIB$ 뒤에 붙는 접미사는 CGLIB이 메서드를 구분하고 관리하기 위해서 사용하는 내부 식별자라고 한다. 이는 내부 메커니즘에 의해서 바뀔 수 있으니 참고만 하도록 한다.

그리고 저번에 의아했던 '왜 @Transactional 이 붙은 어떤 메서드는 CGLIB 경로가 나오고, 어떤 메서드는 CGLIB 경로가 아닌 원본 경로가 나올까?' 에 대해서 분석해 보았다. 이는 경로를 추출하는 내 비즈니스 로직이 잘못 추출했던 것이었다 ㅠㅠ

이를 해결하기 위해서 경로 추출 로직(StackTrace 에서 추출)에서  CGLIB, JDK 동적 프록시, JDK 리플렉션, Java 람다 경로들을 제외하는 로직을 추가하였다. 또한 다른 팀이 제공하는 공통 라이브러리(의존성)에서 발생한 에러들도 상세 경로 추출 로직에서 제외하는 로직을 추가하였다.

이렇게 함으로써 상세경로에 순수 내부 모듈에 존재하는 순수 메서드 경로만 추출할 수 있게 되었다. 일단 원인을 찾아서 해결은 했지만 배포를 하고 또 이상한 점이 발견되면 다시 해결해서 배포해야겠지..? 우선 지금까지 발견된 결함이 이 정도였으니 6월 초에 배포할 예정이다.