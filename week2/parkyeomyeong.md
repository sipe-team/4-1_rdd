# Week2 - 사용 스택 선정 및 구현
## Teams 를 활용한 업무 활동알림 시스템 구축

### [2025.05.18] **메시지 큐 도구 선정 : RabbitMQ로 선정과 이유**

**1. 기업에서도 자유롭게 사용할 수 있는 오픈소스**

- RabbitMQ는 **Mozilla Public License 2.0** 기반의 **완전한 오픈소스 소프트웨어**로,
- ERP 시스템처럼 상업 환경에서도 **무료로 제약 없이 사용 가능**함.
- 별도의 비용 없이 구축 및 운영이 가능하여, **비용 효율적인 시스템 구성**이 가능함.

**2. 디스크 기반 저장 지원으로 메모리 한계 걱정 없음**

- RabbitMQ는 **큐와 메시지를 디스크에 저장할 수 있는 옵션**을 제공함.
- 메시지를 일시적으로 처리하지 못하는 경우에도 **메모리 오버플로우 없이 안정적 운영** 가능.
- 서버 재시작 등 장애 상황에서도 **메시지를 복구할 수 있어 안정성 확보**에 유리함.

**3. 알림처럼 중요도는 낮지만 안정성이 필요한 작업에 적합**

- ERP에서 사용하는 **Teams 알림**은 즉시성이 절대적인 작업은 아니지만, **메시지 손실 없이 전달되는 것이 중요**함.
- RabbitMQ는 **지연이 약간 있어도 안정적으로 메시지를 처리**하기에 적합함.
- **초당 메시지량(TPS)이 낮은 업무**에서는 충분한 성능을 제공하면서도 시스템 자원 소비는 최소화할 수 있음.

**4. Java Spring Boot와의 연동이 간단하고 잘 문서화되어 있음**

- @RabbitListener와 같은 어노테이션 기반 구조로 **Spring Boot와의 연동이 매우 쉽고 직관적**함.
- 실시간 처리보다는 **비동기 처리와 안정성 위주의 아키텍처에 최적화**되어 있어, 기존 ERP 시스템에도 무리 없이 통합 가능함.

## [2025.05.19 ~ 2025.05.20]

## **RabbitMQ 기반 Teams 업무 알림 시스템 구축**

### **프로젝트 목표**

- ERP/내부 시스템 이벤트를 기반으로 Microsoft Teams에 업무 알림 자동 발송
- 메시지 처리 안정성과 API 호출 제약(429) 대응을 위한 아키텍처 설계

---

### **시스템 설계 및 구현 내용**

### **✅ 1. 운영/개발 환경 일치 기반의 안정적 테스트 구조 마련**

- 운영 서버(CentOS)의 환경과 동일한 조건으로 Windows 개발 환경에 RabbitMQ 및 Java, Spring Boot 세팅 구성
- RabbitMQ 데이터 저장 경로, Erlang/RabbitMQ 버전, Durable Queue 등 핵심 설정을 운영과 동일하게 세팅
    
    ➤ 로컬에서 테스트한 로직을 운영에 그대로 적용 가능하도록 구성
    

---

### **✅ 2. 업무 알림 전달 구조 구성 (알람 → 메시지 큐 → Teams)**

- ERP 내 WAS 서버에서 알림 발생 시 RabbitMQ 큐로 메시지 전송
- 워커 서버에서 수신 후 Microsoft Teams API로 채팅 메시지 전송 처리
- 각 단계 간 결합도를 낮추고 비동기 처리 기반으로 안정성 확보

---

### **✅ 3. 메시지 포맷 및 수신 처리 로직 설계**

- 메시지는 DTO 객체(AlertMessage)를 통해 주고받되,
    
    Spring AMQP 내부에서 **Jackson2JsonMessageConverter를 사용하여** 메시지를 JSON 형식으로 자동 변환해서, 서로 DTO 객체로 주고받을 수 있도록 설정했다”
    
    - 예시
        - 송신자 : DTO → JSON 문자열 (직렬화)
        - 수신자 : JSON → DTO 객체 (역직렬화)
- @RabbitListener 기반 메시지 수신, deliveryTag와 Channel을 활용한 수동 ACK 모드 설정

---

### **✅ 4. 예외/재시도 로직 구현 및 테스트**

- Teams API 호출 결과에 따라 다음과 같이 분기 처리:
    - ✅ 201: 성공 시 수동 ACK
    - ⚠️ 429 Too Many Requests: Retry-After 헤더 기반으로 Thread.sleep 후 retryCount를 증가시켜 재전송 (max 3회)
    - ❌ 기타 에러(예: 404, 토큰 문제 등): 재시도 없이 DB 로그 또는 로그 수집만 진행
- retryCount가 메시지 객체에 포함되며, 재전송 시 직접 증가 후 다시 큐에 넣는 방식 (max 3회까지만)
- 모든 메시지 처리 후에는 channel.basicAck(...) 또는 basicNack(...)을 명확히 구분하여 리소스 누수/중복 방지 (ACK 처리)

---

### **주요 기술 스택**

- RabbitMQ 3.12.x
- Spring Boot 3.x (AMQP, Jackson)
- Java 8 환경 대응 (GSON, HttpClient)
- Microsoft Graph API (Teams 채팅 전송)
- CentOS 운영 서버 + Windows 개발 환경

### 참고

- AMQP (Advanced Message Queuing Protocol) : 메시지를 안전하게 주고받기 위한 표준 메시징 프로토콜
    
    → RabbitMQ는 AMQP 기반으로 동작함
    
    → **메시지를 보내고, 큐에 저장하고, 받아서 처리하는 전체 규칙을 정한 약속**
    
- ACK(Acknowledgment) : 메시지를 정상적으로 처리했음을 브로커(RabbitMQ)에 알려주는 신호
    
    → ACK가 없으면 메시지는 다시 큐로 들어가 재시도 됨
    
    → 실수로 중복 처리되거나, 유실되는 걸 방비하는 역할

## [Week3 과제]추가 보완, 고려 사항

- 팀즈 API로 알람 전송 시 필요한 Access key를 가져오는 구조 변경 필요
    
    → 현재는 DB 저장, 가져오는 구조
    
- 알람통해 업무를 진행했던 추적 데이터 관리 구조 설계
- 알람 전송 성공/에러 모니터링에 필요한 로그 저장 구조 설계
- 알람 사용량 예측 및 실제 반영으로 안정적인 운영 결과 확보
